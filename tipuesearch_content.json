{"pages":[{"text":"曾经有很多人问我，Windows界面那么好看，Windows用起来那么方便，为什么还说喜欢用Linux？ 我从未回答，因为我很难说清楚，我喜欢Linux不是因为装B~~ 今天有了答案，感谢 William E. Shotts, Jr. Linux 可以激发我们的想象 当我被要求解释 Windows 与 Linux 之间的差异时,我经常拿玩具来作比喻。 Windows 就像一个游戏机。你去商店,买了一个包装在盒子里面的全新的游戏机。 你把它带回家,打开盒子,开始玩游戏。 精美的画面,动人的声音。玩了一段时间之后, 你厌倦了它自带的游戏,所以你返回商店,又买了另一个游戏机。这个过程反复重复。 最后,你玩腻了游戏机自带的游戏,你回到商店,告诉售货员,\"我想要一个这样的游戏!\" 但售货员告诉你没有这样的游戏存在,因为它没有\"市场需求\"。然后你说,\"但是我只 需要修改一下这个游戏!\",售货 员又告诉你不能修改它。所有游戏都被封装在它们的 存储器中。到头来,你发现你的玩具只局限于别人为你规定好的 游戏。 另一方面,Linux 就像一个全世界上最大的建造模型。 你打开它,发现它只是一个巨大的 部件集合。有许多钢支柱,螺钉,螺母,齿轮,滑轮,发动机,和一些怎样来建造它的说明书。 然后你开始摆弄它。你建造了一个又一个样板模型。 过了一会儿,你发现你要建造自己的模型。 你不必返回商店,因为你已经拥有了你需要的一切。 建造模型以你构想的形状为模板,搭建 你想要的模型。 当然,选择哪一个玩具,是你的事情,那么你觉得哪个玩具更令人满意呢?","tags":"Life","loc":"http://wbowam.github.io/wei-shi-yao-xi-huan-linux.html","title":"为什么喜欢Linux"},{"text":"闲聊 抓取回来的英文资料需要翻译，当然用google翻译API 一行行的翻译，一行大概687ms，两万多行， 汗！！需要几个小时啊！！不能接受！我要并发！！！！ 要分割文件了，要知道我刚刚才合并过的 这次不饶弯路了,用shell命令 split ＃分割成 10 个文件 split - n 10 all . txt seg - # 或 按行分割，每500行 split - l 500 all . txt seg -","tags":"IT","loc":"http://wbowam.github.io/linuxfen-ge-wen-jian.html","title":"Linux分割文件"},{"text":"闲聊 我爬一个网站数据时发现，需要４个小时． 汗！不能接受！我要并发！！！ 于是我需要把抓回来的文件合并在一起 作为pythoner,第一个想到的是这种方案 import glob source_files = glob . glob ( \"*.txt\" ) #这里可以是任何正则 result_file = open ( \"result.txt\" , \"a\" ) : for source_file in source_files : f = open ( source_file , \"r\" ) : result_file . write ( f . read ()) f . close () result_file . close () 在看TLCL时发现可以这样 $ cat * . txt > result . txt 哈哈哈，就这么决定了","tags":"IT","loc":"http://wbowam.github.io/linuxhe-bing-wen-jian.html","title":"Linux合并文件"},{"text":"mysql change character ALTER DATABASE databasename CHARACTER SET utf8 COLLATE utf8_unicode_ci ; ALTER TABLE tablename CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci ; load data from file LOAD DATA INFILE \"/home/paul/clientdata.csv\" INTO TABLE CSVImport COLUMNS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' ESCAPED BY '\"' LINES TERMINATED BY '\\n' IGNORE 1 LINES ; # 如 LOAD DATA INFILE \"haici-two-all.csv\" INTO TABLE enname . name COLUMNS TERMINATED BY \" \\t \" ( meaning , name , zh_name , sex , pronunciation , source ); display history of queries cat ~/ . mysql_history Show Full Column Details of a Table SHOW FULL COLUMNS FROM enname . name ; 或 DESCRIBE table_name ; Counting rows SELECT COUNT ( * ) FROM enname . name ; empty a table TRUNCATE table_name ; Get length of data of column SELECT char_length ( meaning ) FROM enname . name where name = \"zoe\" ; Ubuntu中配置Mysql编码 mysql的配置文件 /etc/mysql/my.cnf 中对应位置加入： [ client ] default - character - set = utf8 [ mysql ] default - character - set = utf8 [ mysqld ] collation - server = utf8_unicode_ci init - connect = ' SET NAMES utf8 ' character - set - server = utf8 Adding ID (auto increment, primary key) after table exist? ALTER TABLE name add column Id INT NOT NULL AUTO_INCREMENT FIRST , ADD primary KEY Id ( Id ); delete duplicate rows in mysql DELETE n1 FROM name n1 , name n2 WHERE n1 . id > n2 . id AND n1 . name = n2 . name ; count with condition select count ( * ) from old_name where meaning = '' ; select count ( * ) from old_name where meaning is not null ; join and dump select * from name as n RIGHT JOIN old_name ON ( old_name . name = n . name ) into outfile \"combined1.csv\" fields terminated by '\\t' lines terminated by '\\ r \\ n ' ; copy an existing table CREATE TABLE newtable LIKE oldtable ; INSERT newtable SELECT * FROM oldtable ; # if necessary","tags":"IT","loc":"http://wbowam.github.io/mysql-dai-ma-pian-duan.html","title":"Mysql 代码片段"},{"text":"python logging import logging logging . basicConfig ( filename = os . path . join ( os . getcwd (), ' log . txt ' ), level = logging . DEBUG ) logging . debug ( ' this is a message ' ) python get line num f = open ( \"test.txt\" ) for i , l in enumerate ( f ) : print i python 脚本基本结构 import sys source_file = sys . argv [ 1 ] if __name__ == \"__main__\" : my_func ( source_file ) python file f = open ( file , \"a\" ) ## a meaning append f = open ( file , \"w\" ) ## w meaning write python 正则 import re pattern = re . compile ( \"[a-zA-Z]\" ) result = pattern . search ( \"adsfuhefdfkj435\" ) print result . group () python 下载静态文件，如,mp3 import urllib urllib . urlretrieve ( audio_url , \"name.mp3\" ) 升级pip easy_install -U pip","tags":"IT","loc":"http://wbowam.github.io/python-dai-ma-pian-duan.html","title":"Python 代码片段"},{"text":"-hl 参数 ls - hl - h , -- human - readable with - l , print sizes in human readable format ( e . g ., 1 K 234 M 2 G ) $ df - hl Filesystem Size Used Avail Use % Mounted on / dev / sda5 92 G 20 G 68 G 23 % / none 4.0 K 0 4.0 K 0 % / sys / fs / cgroup udev 2.9 G 4.0 K 2.9 G 1 % / dev tmpfs 584 M 1.3 M 582 M 1 % / run none 5.0 M 0 5.0 M 0 % / run / lock none 2.9 G 21 M 2.9 G 1 % / run / shm none 100 M 32 K 100 M 1 % / run / user man 命令比 help 更可阅读 shell: count files in dir ls -1 | wc -l shell: size of dir du -hl dir/","tags":"IT","loc":"http://wbowam.github.io/shell-dai-ma-pian-duan.html","title":"Shell 代码片段"},{"text":"笔记开始 命令行最酷的特性。它叫做 I/O 重定向 标准输入，标准输出，标准错误 ls -l /bin/usr > ls-error.txt 把标准输出写入（重定向）到文件 ls -l /bin/usr >> ls-error.txt 把标准输出追加到（重定向）到文件（在文件末尾继续添加） cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样 原来如此 往标准输出写入东西，可以达到往别人屏幕输出东西的目的吗？ 命令的输入来自文件，输出也存至文件 哈哈，在Unix一切都是文件 我们用到的许多程序都会产生某种输出.这种输出，经常由两种类型组成． 第一，程序的运行结果（程序要完成的功能所在） 第二，状态或错误信息（程序的进展） 输出结果都会写入到某种文件吗？ 观察一下会发现，很多程序的这两种结果都会输出在屏幕上 其实与Unix主题\"任何东西都是文件\"保持一致，程序会把上述两种结果输送到两个叫做标准输出(stdout)和标准错误(stderr)的文件． 默认情况下，标准输出和标准输入都会连接到屏幕上 那可不可以这样子：往别人电脑的标准输出写入message，达到聊天的目的？？？？ 类似，程序会从标准输入读取输入．标准输出默认连接到键盘． 这里好抽象了一个层面啊．屏幕怎么连接到标准输出；键盘怎么连接到标准输入？ I/O重定向其实就是允许我们更改输出走向和输入来向． 默认的输入来自键盘，输出去向屏幕． 重定向标准输出到另一个文件(除了屏幕)，我们使用\">\"重定向符号． 这种做法应该很有用吧．．．．． 有时候吧结果输出到另外一个文件很有用处． 实例（干货来也） #看看标准输入，标准输出和标准错误 $ ls test test1 . txt ls: cannot access test1 . txt : No such file or directory test: index . html main . js styles . css #输出标准输出到文件 $ ls test test1 . txt > result . txt ls: cannot access test1 . txt : No such file or directory $ cat test2 . txt test: index . html main . js styles . css 默认情况下可以缩写\"1>\"(上述命令相当于 ls test test1.txt 1>result.txt ); 标准错误照样输出到屏幕 #标准错误也输出到文件 ls test test1 . txt 1 > result . txt 2 > err . txt #有时候我们想把结果追加写入文件而不是覆盖写入 ls test test1 . txt 1 >> result . txt 2 >> err . txt #有时候我们需要丢掉错误信息 ls test test1 . txt 1 >> result . txt 2 >>/ dev / null #可以缩写为 ls test test1 . txt 1 >> result . txt 2 >>&- /dev/null 是linux黑洞，当垃圾箱用 #于是有人关掉所有的输出 ls test test1 . txt 1 >&- 2 >&- #可以缩写为 ls test test1 . txt 1 >&- 2 >& 1 #或 ls test test1 . txt &>/ dev / null 一直在说标准输出和标准错误 重定向标准输入 cat 命令读取一个或多个文件，然后重定向它们到标准输出 -- 原来如此啊 -- 是的 于是cat有了个 强大的功能 combine file segments 说道这个，可以看看我是怎么做分割与合并文件了 cat seg -* > result . txt 不给cat任何参数，它会读取标准输入，输出到标准输出 #输入cat，输入一些文本，按Ctrl+D结束 $ cat sdfdsgdsg sgdfgdf sdfdsgdsg sgdfgdf 通过这个可爱的命令，我们可以实现世界上最小巧的文件创建器 cat > new_file.txt 怎么还没提过标准输入啊 想想下面的命令是如何重定向标准输入的 cat < from.txt cat 默认会读取标准输入，转输出到标准输出．这里把 from.txt s输出到标准输入了 再看看下面的几个例子 cat > catfile testing cat file test #这里按下 [ctrl]+d 离开 #从标准输入【键盘】获得数据，然后输出给catfile文件 cat > catfile < test . sh #cat 从test.sh 获得输入数据，然后输出给文件catfile cat > catfile << eo test a file test ! eof #<< 这个连续两个小符号， 他代表的是『结束的输入字符』的意思。这样当空行输入eof字符，输入自动结束，不用ctrl+D 第二个和第三个例子里，为什么先执行后面呢？ 管道 使用管道操作符\"|\"(竖杠),一个命令的 标准输出可以管道到另一个命令的标准输入 command1 | command2 命令一的标准输出重定向到命令二的标准输入．如在统计目录内的文件总数 ls | wc -l 过滤器 管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常,以这种方式使用的命令被称 为过滤器。 其实是这样的 command1 | 过滤 | command2 过滤一下命令一的结果，重定向到命令二的标准输入 $ ls /bin /usr/bin | sort | less sort 用于产生一个 有序列表 $ ls /bin /usr/bin | sort | uniq | less uniq 忽略重复行 wc -打印行,字和字节数 $ wc ls-output.txt 7902 64566 503634 ls-output.txt $ ls /bin /usr/bin | sort | uniq | wc -l 2736 grep grep -打印匹配行 grep pattern [file...] grep 能够匹配的模式可以 很复杂,但是现在我们把 注意力集中在简单文本匹配上面。在后面的章节中,我们将会研究 高级模式,叫做正则表达式。 grep :\"-i\"忽略大小写(通常,搜索是大小写 敏感的), \"-v\"选项会告诉 grep 只打印不匹配的行。 tailf head / tail -打印文件开头部分/结尾部分 $ head -n 5 ls-output.txt $ tail -n 5 ls-output.txt 管道线中 $ ls /usr/bin | tail -n 5 实时的浏览文件 tail -f /var/log/messages 或 tailf /var/log/messages","tags":"Reading","loc":"http://wbowam.github.io/tlcl-kan-shu-bi-ji-3.html","title":"TLCL 看书笔记(3)"},{"text":"1. git工作流 你的本地仓库由 git 维护的三棵\"树\"组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 2. 本地仓库连接到远程仓库 git remote add origin <server> 如: ## 我的本地文件加到我的博客 cd output / git init git remote add origin https : //github.com/tulpar008/blog.git git pull git add . git commit - m \"for test\" git push","tags":"It","loc":"http://wbowam.github.io/git-fu-xi-gong-gu-1.html","title":"git 复习巩固(1)"},{"text":"1. 对象名 6ff87c4664981e4397625791c8ea3bbb5f2279a3 所有用来表示项目历史信息的文件,是通过一个40个字符的（40-digit）\"对象名\"来索引的. 每一个\"对象名\"都是对\"对象\"内容做SHA1哈希计算得来的，（SHA1是一种密码学的哈希算法）。这样就意味着两个不同内容的对象不可能有相同的\"对象名\"。 2. 对象 有四种类型的对象：\"blob\"、\"tree\"、 \"commit\" 和\"tag\" 3. Blob 对象 新文件纳入到 Git 后会被五马分尸，它的内容被扔到在一个 blob 对象中，它的对象名是基于内容运算生成的一个 40个字符的 SHA1值。 blob 没有文件名，只有内容。 4. Tree 对象 一个 tree 对象就是一大坨指针，指向： 其他 small tree（子级 tree） blob 可以把 Tree 对象想象为 Linux 文件系统中的目录，记录了子目录的信息、文件信息。 5. Commit 对象 一个 commit 对象由以下几部分组成 作者 提交者 注释 指向一个 big tree 的指针 6. 我们已经了解了3种主要对象类型(blob, tree 和 commit), 让我们大概了解一下它们怎么组合到一起的 如果我们一个小项目, 有如下的目录结构: $ > tree . |-- README ` -- lib |-- inc | ` -- tricks . rb ` -- mylib . rb 2 directories , 3 files 如果我们把它提交(commit)到一个Git仓库中, 在Git中它们也许看起来就如下图: 可以看到: 每个目录都创建了 tree对象 (包括根目录), 每个文件都创建了一个对应的 blob对象 . 最后有一个 commit对象 来指向根tree对象(root of trees), 这样我们就可以追踪项目每一项提交内容. 看到","tags":"It","loc":"http://wbowam.github.io/git-fu-xi-gong-gu-2.html","title":"git 复习巩固(2)"},{"text":"1. Working Directory（工作目录） Git的工作目录是保存当前正在工作的文件所在的目录，和working tree是相同的意思。在这个目录中的文件可能会在切换branch时被GIT删除或者替换。这个目录是个临时目录，临时存储你从GIT库中取出的文件，这些文件一直会被保存，直到下次提交。 2.Git索引 Git索引是一个在你的工作目录和项目仓库间的暂存区(staging area). 有了它, 你可以把许多内容的修改一起提交(commit). 如果你创建了一个提交(commit), 那么提交的是当前索引(index)里的内容, 而不是工作目录中的内容. 3. 仓库","tags":"It","loc":"http://wbowam.github.io/git-fu-xi-gong-gu-3.html","title":"git 复习巩固(3)"},{"text":"分支 ＃ 新建分支 git branch branch-name 新建并切到该分支 git checkout -b branch-name 删除分支 $ git branch -d experimental -d只能删除那些已经被当前分支的合并的分支. 强制删除某个分支的话就用 –D $ git branch -D crazy-idea 合并冲突 git merge branch - name 100 % ( 4 / 4 ) done Auto - merged file . txt CONFLICT ( content ) : Merge conflict in file . txt Automatic merge failed ; fix conflicts and then commit the result . 解决合并中的冲突 有冲突(conflicts)的文件会保存在索引中，除非你解决了问题了并且更新了索引，否则执行 git commit都会失败: git commit file . txt : needs merge 撒销一个合并 放弃修改撤回到本分支头部 git reset --hard HEAD 或 git checkout -f 撤回到之前的commit git reset 4ba467213eb73480431b95c7dba03aac1c7a2c26","tags":"It","loc":"http://wbowam.github.io/git-fu-xi-gong-gu-4.html","title":"git 复习巩固(4)"},{"text":"fetch all git branches git fetch --all 但是 git branch 不会显示信拉下来的分支列表，直接checkout就行","tags":"It","loc":"http://wbowam.github.io/git-fu-xi-gong-gu-5.html","title":"git 复习巩固(５)"},{"text":"声明： 这不是shell入门文章， 这不是TLCL(The Linux Command Line)评语， 这甚至不是逻辑清晰的文章， 是的，本文逻辑会很混乱， 因为这是我的看书笔记． 仅供本人日后翻阅，因此本文会有很多胡言乱语，只有本人能看懂． 欢迎吐槽，请先绕过！ 1. TLCL The Linux Command Line 作者: William E. Shotts, Jr. 笔记开始 cd ~{username} 更改工作目录到用户主目录． （一直用~，但不知道这个的全称） Linux 没有\"文件扩展名\"的概念，不像其它一些系统。 这个以前没有想到过 ls ~ /usr 可以传两个以上的目录，，好神奇 有充分的理由证明，ls 可能是用户最常使用的命令。 之前注意到，自己有一些习惯，如在命令行下无意识中打ls，在vi中保存生疏命令 ls 命令的\"-l\"选项，则结果以长模式输出。 \"l\" 选项产生长格式输出，\"t\"选项按文件修改时间的先后来排序。 ls 命令常用的参数 - l 选项产生长格式输出 - t 选项按文件修改时间的先后来排序。 - a 列出目录下的所有文件，包括以 . 开头的隐含文件。 - s 在每个文件名后输出该文件的大小。 ls命令比较复杂的用法，可参看 每天一个linux命令(1)：ls命令 Linux，有个普遍的观念就是\"任何东西都是一个文件\"。 随着课程的进行，我们将会明白这句话的真谛。 其他系统不是这样的吗，怎么个不这样法 file 命令会打印出文件内容的简单描述 file picture . jpg picture . jpg : JPEG image data , JFIF standard 1.01 less 程序是早期 Unix 程序 more 的改进版。\"less\" 这个名字，对习语 \"less is more\" 开了个玩笑， 这个习语是现代主义建筑师和设计者的座右铭。 记得复制和粘贴技巧！如果你正在使用鼠标，双击文件名，来复制它，然后按下鼠标中键，粘贴文件名到命令行中。 平时用Crl+Shift+C,好渣啊 在系统中游玩时，不要害怕粘花惹草。普通用户是很难把东西弄乱的。那是系统管理员的工作！ 如果一个命令抱怨一些事情，不要管它，尽管去玩别的东西。花一些时间四处走走。 系统是我们自己的，尽情地探究吧。记住在 Linux 中，没有秘密存在！ MFJ很喜欢翻来翻去（我说的不是在床上哈~~） 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 平时可以翻翻 如下： / etc / crontab ， 定义自动运行的任务。 / etc / fstab ，包含存储设备的列表，以及与他们相关的挂载点。 / etc / passwd ，包含用户帐号列表。 在现在的 Linux 系统中，/media 目录会包含可移除媒体设备的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。 以前，三年前吧,,,大一下学期的样子，入门过linux文件系统,挂载等知识点，现在想想忘完了 有趣的文件： / boot / grub / grub . conf or menu . lst ， 被用来配置启动加载程序。 / boot / vmlinuz ， Linux 内核。 系统内核哈，看到眼前一亮，可以折腾折腾 一个程序要求使用某个包含在名为\"foo\"文件中的共享资源，但是\"foo\"经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个\"foo\"版本。 这又会导致一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。 这就是符号链接存在至今的原因。 这是一个关于软链接的故事。讲述了软链接活着的意义~~","tags":"Reading","loc":"http://wbowam.github.io/tlcl-kan-shu-bi-ji-1.html","title":"TLCL 看书笔记(1)"},{"text":"笔记开始 坦诚地说，用图形文件管理器来完成一些由这些命令执行的任务会更容易些。 cp -u *.html destination 那么， 为什么还使用早期的命令行程序呢？ 会有很多小白问这个问题，，，，，，，我总是说不清楚自己为什么喜欢命令行 命令行程序，功能强大灵活。虽然图形文件管理器能轻松地实现简单的文件操作，但是对于 复杂的文件操作任务，则使用命令行程序比较容易完成。 答案来了～这是为什么极客们喜欢用Linux ln — 创建硬链接和符号链接 mkdir dir1 dir2 dir3 原来也可以传多个参数啊， mk blog blog/content 接受文件名作为参数的任何命令，都可以使用通配符 到目前为止，我以为通配符就是正则，，难道我有错吗？ cp item... directory 原来能一次性复制好多文件， 三个点表示能接受多个参数 cp file1 file2 复制文件 file1 内容到文件 file2。 如果 file2 已经存在，file2 的内容会被 file1 的 内容重写。 如果 file2 不存在，则会创建 file2。 cp -i file1 file2 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前，会提示用户确认信息。 cp file1 file2 dir1 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 cp dir1/* dir2 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 cp -r dir1 dir2 这里的 r 参数是递归的意思，如下 cp - R , - r , -- recursive copy directories recursively 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项） - u , -- update 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 - f , -- force Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了。Linux 假定你很聪明，你知道你在做什么。 曾经亲身经历过这么悲催的事情，，，那是一个蛋疼的上午和中午，我写了一个上午的代码啊～～本来我想删swp文件的，一不小心．．．当时我是正准备commit 的 小贴士。 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls。 嗯嗯，当构造复杂的通配符时，可以先用这个技巧验证一下 符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。 普通文件是由文件名和指针组成 符号链接是由文件名和指向目标文件的指针 我的理解对吗？ 符号链接类似Windows的快捷方式 当然，符号链接早于 Windows 的快捷方式 很多年;-) 作者很逗，总是在讽刺widows的抄袭(这是软链接的笔记，不知怎么的跑到这里了) 一个程序要求使用某个包含在名为\"foo\"文件中的共享资源，但是\"foo\"经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个\"foo\"版本。 这又会导致一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。 这就是符号链接存在至今的原因。 这是一个关于软链接的故事。讲述了软链接活着的意义 ls - l dir1 total 4 - rw - r -- r -- 4 me me 1650 2008 - 01 - 10 16 : 33 fun - hard lrwxrwxrwx 1 me me 6 2008 - 01 - 15 15 : 17 fun - sym -> .. / fun dir1 中，fun-sym 的列表说明了它是一个符号链接，通过在第一字段中的首字符\"l\" 可知，并且它还指向\"../fun\"，也是正确的。相对于 fun-sym 的存储位置，fun 在它的 上一个目录。同时注意，符号链接文件的长度是6，这是字符串\"../fun\"所包含的字符数， 而不是符号链接所指向的文件长度 不太理解，软链接文件的大小是目标文件名(包括路径名哈，但为什么不是绝对路径啊？)的长度,这是因为 Linux，有个普遍的观念就是\"任何东西都是一个文件\"。 随着课程的进行，我们将会明白这句话的真谛。 明白字面上的意思了，但还没震撼过 file 命令会打印出文件内容的简单描述 感觉不是很常用啊 less 程序是早期 Unix 程序 more 的改进版。\"less\" 这个名字，对习语 \"less is more\" 开了个玩笑， 这个习语是现代主义建筑师和设计者的座右铭。 喜欢Unix这种风格 记得复制和粘贴技巧！如果你正在使用鼠标，双击文件名，来复制它，然后按下鼠标中键，粘贴文件名到命令行中 见过几次赵宇这样复制粘贴，很实用的样子 在系统中游玩时，不要害怕粘花惹草。普通用户是很难把东西弄乱的。那是系统管理员的工作！ 如果一个命令抱怨一些事情，不要管它，尽管去玩别的东西。花一些时间四处走走。 系统是我们自己的，尽情地探究吧。记住在 Linux 中，没有秘密存在！ 这话足够风趣，够吸引人 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 平时可以翻翻 /etc/crontab， 定义自动运行的任务。 /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。 /etc/passwd，包含用户帐号列表。 自动运行的任务哈，，可以写到一些配置文件里哈 在现在的 Linux 系统中，/media 目录会包含可移除媒体设备的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。 曾经学过怎么挂载硬盘或U盘，现在忘记了，因为Ubuntu的自动挂载 type－显示命令的类型 $ type ls ls is an alias for ls -- color = tty $ type cp cp is / bin / cp alias – 创建命令别名 alias fj = ssh tulpar @ 127.0.0.1 由于阅读难度而能拿到特等奖的手册页应该是 bash 手册页。 哈哈哈，所以我刚刚才跨国 man zless 可以显示由gzip 压缩的文本文件的内容。 直接解压看不行吗，非要个这样的命令吗？ 可以把多个命令放在同一行上，命令之间 用\";\"分开。 这个知识点实用，必须掌握 alias foo='cd /usr; ls; cd -' 想知道重新登录这个配置还在吗? 肯定不在了哈...所以写到 .bashrc grep － 打印匹配行 神一样的命令终于出现了，看到这里我再次确定这是一本好书了 话说XX推荐用 ACK 替代grep","tags":"Reading","loc":"http://wbowam.github.io/tlcl-kan-shu-bi-ji-2.html","title":"TLCL 看书笔记(2)"}]}